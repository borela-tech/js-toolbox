// Licensed under the Apache License, Version 2.0 (the “License”); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an “AS IS” BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

import debug from 'debug'
import validateOptions from 'schema-utils'
import {getSettings} from '../../../settings'
import {html as beautifyHtml} from 'js-beautify'
import {JSDOM} from 'jsdom'
import {minify as minifyHtml} from 'html-minifier'
import {readFileSync} from 'fs'

let log = debug('bb:config:webpack:plugin:html')

let {minify = false} = getSettings()
const PLUGIN_NAME = 'SPA HTML Plugin'

/**
 * This schema is used to validate the plugin’s options, right now, all it does
 * is requiring the template property.
 */
const OPTIONS_SCHEMA = {
  additionalProperties: false,
  type: 'object',
  properties: {
    template: {
      type: 'string',
    },
  },
  required: ['template'],
}

/**
 * Actual Webpack plugin that generates an HTML from a template, add the script
 * bundles and and loads any local assets referenced in the code.
 */
export default class SpaHtml {
  /**
   * DOM of the loaded template.
   */
  dom = undefined

  /**
   * Options passed to the plugin.
   */
  options = undefined

  constructor(options) {
    this.options = options
    validateOptions(OPTIONS_SCHEMA, this.options, PLUGIN_NAME)

    // Load the template.
    const SOURCE = readFileSync(this.options.template, 'utf8')
    this.DOM = new JSDOM(SOURCE)
  }

  apply(compiler) {
    compiler.hooks.make.tapAsync(PLUGIN_NAME, this.tapMake.bind(this))
    compiler.hooks.emit.tapAsync(PLUGIN_NAME, this.tapEmit.bind(this))
  }

  getFinalHtml() {
    // Modified HTML.
    let serialized = DOM.serialize()

    // We pass the serialized HTML from JSDOM through the minifier to remove any
    // unnecessary whitespace that could affect the beautifier. When we are
    // actually trying to minify, comments will be removed too. Options can be
    // found in:
    //
    //     https://github.com/kangax/html-minifier
    //
    const MINIFIER_OPTIONS = {
      caseSensitive: false,
      collapseBooleanAttributes: true,
      collapseInlineTagWhitespace: true,
      collapseWhitespace: true,
      conservativeCollapse: false,
      decodeEntities: true,
      html5: true,
      includeAutoGeneratedTags: false,
      keepClosingSlash: false,
      preserveLineBreaks: false,
      preventAttributesEscaping: true,
      processConditionalComments: false,
      quoteCharacter: '"',
      removeAttributeQuotes: true,
      removeEmptyAttributes: true,
      removeEmptyElements: false,
      removeOptionalTags: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true,
      sortAttributes: true,
      sortClassName: true,
      useShortDoctype: true,
    }

    if (minify) {
      // Minify.
      serialized = minifyHtml(serialized, {
        minifyCSS: true,
        minifyJS: true,
        removeComments: true,
        ...MINIFIER_OPTIONS,
      })
    } else {
      // Beautify.
      serialized = minifyHtml(serialized, MINIFIER_OPTIONS)
      serialized = beautifyHtml(serialized, {
        indent_char: ' ',
        indent_inner_html: true,
        indent_size: 2,
        sep: '\n',
        unformatted: ['code', 'pre', 'em', 'strong', 'span'],
      })
    }

    return serialized
  }

  async tapEmit(compilation, done) {
    // TODO: Inject the JS bundles.

    // Add the template to the dependencies to trigger a rebuild on change in
    // watch mode.
    compilation.fileDependencies.add(this.options.template)

    // Emit the final HTML.
    let source = this.getFinalHtml()
    compilation.assets['index.html'] = {
      source: () => source,
      size: () => source.length,
    }

    done()
  }

  async tapMake(compilation, done) {
    // TODO: Load any assets from the template.
    done()
  }
}
